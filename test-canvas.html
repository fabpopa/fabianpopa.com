<!DOCTYPE html>
<style>
  * { margin: 0; padding: 0; }
  body { background: black; margin-top: 100px; }
  /*canvas { transform-origin: center; transform: rotate(-10deg); }*/
</style>

<canvas>No support.</canvas>

<script>
  // convenience math functions
  const rnd = function() { return Math.random(); };
  const rou = function(x) { return Math.round(x); };
  const flr = function(x) { return Math.floor(x); };
  const cei = function(x) { return Math.ceil(x); };
  const sin = function(x) { return Math.sin(x); };
  const tan = function(x) { return Math.tan(x); };
  const abs = function(x) { return Math.abs(x); };
  const pow = function(x, y) { return Math.pow(x, y); };
  const msPrg =
    function(sec) { return Date.now() % (sec * 1000) / (sec * 1000); };
  const PI = Math.PI;

  const canvas = document.getElementsByTagName('canvas')[0];
  canvas.width = window.innerWidth;
  canvas.height = 200;
  const c = canvas.getContext('2d');
  const opt = {
    sizeMin: 20,    // pixels, even number
    sizeMax: 50,    // pixels, even number
    angleMin: 60,   // degrees
    angleMax: 120,  // degrees
    flipMin: 2,     // seconds
    flipMax: 5,     // seconds
    jiggleMin: 1,   // seconds
    jiggleMax: 2,   // seconds
    buffer: 10,     // pixels, even number
    velocity: 60    // pixels per second
  };

  const cellPool = (function() {
    // choose an object pool size that will not change
    const pool =
      new Array(flr(canvas.width * canvas.height / pow(opt.sizeMin, 2)));

    // populate cell pool
    for (let i = 0; i < pool.length; i++) pool[i] = {
      size: null,       // pixels
      angle: null,      // degrees
      flip: null,       // seconds
      jiggle: null,     // seconds
      jigglePhX: null,
      jigglePhY: null,
      x: null,
      y: null,
      flipFrame: null
    };

    return {
      count: pool.length,
      get: function(i) { return pool[i]; },
      active: function(i) { return pool[i].x !== null; },
      reset: function(i) { pool[i].x = null; },
      new: function(size, angle, flip, jiggle, jigglePhX, jigglePhY, x, y) {
        for (let i = 0; i < pool.length; i++) if (!this.active(i)) {
            pool[i].size = size;
            pool[i].angle = angle;
            pool[i].flip = flip;
            pool[i].jiggle = jiggle;
            pool[i].jigglePhX = jigglePhX;
            pool[i].jigglePhY = jigglePhY;
            pool[i].x = x;
            pool[i].y = y;
            pool[i].flipFrame = 0;
            return i;
          }
        return false;   // if pool empty, should not happen
      }
    };
  })();

  // canvas line at x = 0 to decide when to insert a new cell
  let entryLine = (function() {
    const pixels = new Array(canvas.height);

    return {
      reset: function() {
        for (let i = 0; i < pixels.length; i++) pixels[i] = true;
      },
      mark: function(from, to) {
        if (from < 0) from = 0;
        if (to > pixels.length - 1) to = pixels.length - 1;
        for (let i = from; i <= to; i++) pixels[i] = false;
      },
      window: function() {
        // return largest continuous block of available pixels
        let window = { start: 0, end: 0, size: 0 };
        for (let i = 0, j = 1; j <= pixels.length; j++)
        	if (j == pixels.length || pixels[j - 1] != pixels[j])
          	if (pixels[j - 1]) {
            	if (j - i > window.size) {
              	window.start = i;
                window.end = j - 1;
                window.size = j - i;
              }
            } else i = j;
        return window;
      }
    };
  })();

  // frame-duration cache
  let fc = {
    rdX: null, rdY: null, ctlX: null, ctlY: null, flipPerc: null,
    sX: null, sY: null
  };

  let renderCellPath = function() {
    c.beginPath();
    c.moveTo(0, -fc.rdY);
    c.bezierCurveTo(fc.ctlX, -fc.rdY, fc.rdX, -fc.ctlY, fc.rdX, 0);
    c.bezierCurveTo(fc.rdX, fc.ctlY, fc.ctlX, fc.rdY, 0, fc.rdY);
    c.bezierCurveTo(-fc.ctlX, fc.rdY, -fc.rdX, fc.ctlY, -fc.rdX, 0);
    c.bezierCurveTo(-fc.rdX, -fc.ctlY, -fc.ctlX, -fc.rdY, 0, -fc.rdY);
  };

  let renderCellFrame = function(cell) {
    // compute animation state
    if (cell.flipFrame === cell.flip * 60) cell.flipFrame = -1;
    cell.flipFrame += 1;
    fc.flipPerc = cell.flipFrame / cell.flip / 60 * 100;

    // enter canvas state
    c.save();

    // compute outside path
    fc.rdX = cell.size / 2;
    fc.rdY = fc.rdX * (.2 + .8 * abs(fc.flipPerc - 50) / 50);
    fc.ctlX = 4 / 3 * tan(PI / 8) * fc.rdX;   // horizontal bezier handle
    fc.ctlY = fc.ctlX * fc.rdY / fc.rdX;      // vertical bezier handle

    // render outside path
    fc.sX = opt.buffer * sin((msPrg(cell.jiggle) + cell.jigglePhX) * 2 * PI);
    fc.sY = opt.buffer * sin((msPrg(cell.jiggle) + cell.jigglePhY) * 2 * PI);
    c.translate(cell.x + fc.sX / 8, cell.y + fc.sY / 8);
    c.rotate(cell.angle * PI / 180);
    renderCellPath();
    c.fillStyle = 'rgb(242, 116, 116)';
    c.fill();

    // center inside path towards furthest edge of outside path
    c.translate(0, fc.flipPerc < 50 ? -fc.rdY : fc.rdY);

    // compute inside path
    fc.rdX /= 2;
    fc.rdY = fc.rdX * abs(fc.flipPerc - 50) / 50;
    fc.ctlX /= 2;
    fc.ctlY = fc.ctlX * fc.rdY / fc.rdX;

    // render inside path
    if (fc.rdY !== 0) {
      // slide inside path from center of outside path to edge and back
      c.translate(0, fc.flipPerc < 50 ? fc.rdY * 2 : -fc.rdY * 2);
      renderCellPath();
      c.fillStyle = 'rgb(210, 58, 58)';
      c.fill();
    }

    // exit canvas state
    c.restore();

    // advance position
    cell.x += opt.velocity / 60;
  };

  let addCell = function() {
    if (rnd() % .3 > .01) return;  // better spread through likely rejection
    let window = entryLine.window();
    let size = opt.sizeMin + rou(rnd() * (opt.sizeMax - opt.sizeMin));
    if (window.size < size) return;
    cellPool.new(
      size,
      opt.angleMin + rou(rnd() * (opt.angleMax - opt.angleMin)),
      opt.flipMin + rou(rnd() * (opt.flipMax - opt.flipMin)),
      opt.jiggleMin + rou(rnd() * (opt.jiggleMax - opt.jiggleMin)),
      rnd(),
      rnd(),
      0 - size / 2,
      window.start + rou(size / 2 + rnd() * (window.size - size))
    );
  };

  let renderCells = function() {
    // clear canvas and render background
    c.fillStyle = 'rgb(255, 255, 255)';
    c.fillRect(0, 0, canvas.width, canvas.height);

    entryLine.reset();

    // render cells
    for (let i = 0; i < cellPool.count; i++) {
      if (!cellPool.active(i)) continue;
      let cell = cellPool.get(i);
      renderCellFrame(cell);

      // remove cell if outside of canvas
      if (cell.x - cell.size / 2 > canvas.width) cellPool.reset(i);

      // compute entry line
      if (cell.x - cell.size / 2 - opt.buffer < 0)
          entryLine.mark(
            flr(cell.y - cell.size / 2 - opt.buffer),
            cei(cell.y + cell.size / 2 + opt.buffer)
          );
    }

    // take out cell buffer at beginning and end of entry line
    // plus a sin wave of padding
    let padding = rou(abs(canvas.height / 4 * sin(msPrg(5) * 2 * PI)));
    entryLine.mark(0, opt.buffer + padding);
    entryLine.mark(canvas.height - opt.buffer - padding, canvas.height - 1);

    // add new cell
    addCell();
  };

  let raf = function() { renderCells(); window.requestAnimationFrame(raf); };
  raf();
</script>
